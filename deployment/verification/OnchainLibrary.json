{
	"language": "Solidity",
	"sources": {
		"contracts/OnchainLibrary.sol": {
			"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport {IOnchainLibrary} from \"./interfaces/IOnchainLibrary.sol\";\r\nimport {SSTORE2} from \"./lib/SSTORE2/SSTORE2.sol\";\r\nimport {Base64} from \"./lib/solady/utils/Base64.sol\";\r\n\r\n/**\r\n * @title OnchainLibrary\r\n * @author 0xth0mas (Layerr)\r\n * @notice OnchainLibrary is an unowned, immutable repository\r\n *         for onchain assets that anyone may contribute to\r\n *         and use.\r\n *         Data chunks are stored in deterministic addresses \r\n *         to prevent duplicate data from being stored on chain.\r\n *         Pointers to the existing data can be queried and used in\r\n *         new asset files.\r\n */\r\ncontract OnchainLibrary is IOnchainLibrary {\r\n\r\n    uint256 public constant MAX_CHUNK_SIZE = 24575;\r\n\r\n    mapping(uint256 => Asset) public assets;\r\n    mapping(bytes32 => CatalogEntry) private catalog;\r\n    mapping(uint256 => mapping(uint256 => address)) public dataChunks;\r\n\r\n    uint256 public nextAssetId = 1;\r\n\r\n    /**\r\n     * Upload Asset\r\n     */\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function addAsset(string calldata name, bytes32 expectedSHA256Hash, uint32 dataChunkCount) external returns(uint256 newAssetId) {\r\n        newAssetId = nextAssetId;\r\n        unchecked { ++nextAssetId; }\r\n\r\n        Asset storage asset = assets[newAssetId];\r\n        asset.assetId = uint56(newAssetId);\r\n        asset.name = name;\r\n        asset.uploadedBy = msg.sender;\r\n        asset.dataChunkCount = dataChunkCount;\r\n        asset.expectedSHA256Hash = expectedSHA256Hash;\r\n\r\n        CatalogEntry storage catalogEntry = catalog[keccak256(abi.encodePacked(msg.sender))];\r\n        catalogEntry.assets.push(newAssetId);\r\n        emit AssetAdded(newAssetId, expectedSHA256Hash, dataChunkCount, name);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function updateAsset(uint256 assetId, string calldata name, bytes32 expectedSHA256Hash, uint32 dataChunkCount) external {\r\n        Asset storage asset = assets[assetId];\r\n        if(msg.sender != asset.uploadedBy) revert NotUploader();\r\n        if(asset.finalized) revert AssetIsFinalized();\r\n\r\n        asset.name = name;\r\n        asset.dataChunkCount = dataChunkCount;\r\n        asset.expectedSHA256Hash = expectedSHA256Hash;\r\n        emit AssetUpdated(assetId, expectedSHA256Hash, dataChunkCount, name);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function finalizeAsset(uint256 assetId) external {\r\n        Asset storage asset = assets[assetId];\r\n        if(msg.sender != asset.uploadedBy) revert NotUploader();\r\n        if(asset.finalized) revert AssetIsFinalized();\r\n        CatalogEntry storage catalogEntry;\r\n\r\n        asset.finalized = true;\r\n        catalogEntry = catalog[keccak256(abi.encodePacked(asset.expectedSHA256Hash))];\r\n        catalogEntry.assets.push(assetId);\r\n        catalogEntry = catalog[keccak256(bytes(asset.name))];\r\n        catalogEntry.assets.push(assetId);\r\n\r\n        emit AssetFinalized(assetId);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function uploadChunk(uint256 assetId, uint256 chunkId, bytes calldata chunkData) external {\r\n        if(chunkData.length > MAX_CHUNK_SIZE) revert ExceedsMaxChunkSize();\r\n\r\n        Asset storage asset = assets[assetId];\r\n        if(msg.sender != asset.uploadedBy) revert NotUploader();\r\n        if(asset.finalized) revert AssetIsFinalized();\r\n        if(chunkId >= asset.dataChunkCount) revert ExceedsChunkCount();\r\n\r\n        address chunkDataPointer = SSTORE2.write(chunkData);\r\n        dataChunks[assetId][chunkId] = chunkDataPointer;\r\n        emit DataChunkUploaded(assetId, chunkId, chunkDataPointer);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function addChunkByAddress(uint256 assetId, uint256 chunkId, address chunkDataPointer) external {\r\n        Asset storage asset = assets[assetId];\r\n        if(msg.sender != asset.uploadedBy) revert NotUploader();\r\n        if(asset.finalized) revert AssetIsFinalized();\r\n        if(chunkId >= asset.dataChunkCount) revert ExceedsChunkCount();\r\n\r\n        dataChunks[assetId][chunkId] = chunkDataPointer;\r\n        emit DataChunkUploaded(assetId, chunkId, chunkDataPointer);\r\n    }\r\n\r\n    /**\r\n     * Catalog Search\r\n     */\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function searchCatalogByExpectedHash(bytes32 expectedHash) external view returns(Asset[] memory foundAssets) {\r\n        uint256[] memory assetIds = catalog[keccak256(abi.encodePacked(expectedHash))].assets;\r\n        foundAssets = _getAssetsById(assetIds);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function searchCatalogByValidatedHash(bytes32 validatedHash) external view returns(Asset[] memory foundAssets) {\r\n        uint256[] memory assetIds = catalog[keccak256(abi.encodePacked(validatedHash,true))].assets;\r\n        foundAssets = _getAssetsById(assetIds);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function searchCatalogByName(string calldata name) external view returns(Asset[] memory foundAssets) {\r\n        uint256[] memory assetIds = catalog[keccak256(bytes(name))].assets;\r\n        foundAssets = _getAssetsById(assetIds);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function searchCatalogByUploader(address uploadedBy) external view returns(Asset[] memory foundAssets) {\r\n        uint256[] memory assetIds = catalog[keccak256(abi.encodePacked(uploadedBy))].assets;\r\n        foundAssets = _getAssetsById(assetIds);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function getAssetsById(uint256[] memory assetIds) external view returns(Asset[] memory assetArr) {\r\n        assetArr = _getAssetsById(assetIds);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function getDataChunkAddress(bytes calldata dataChunk) external view returns(address pointer, bool isUploaded) {\r\n        (pointer, isUploaded) = SSTORE2.search(dataChunk);\r\n    }\r\n\r\n    /**\r\n     * Hash Validation\r\n     */\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function validateActualAndExpectedHashOnchain(uint256 assetId) external returns(bool) {\r\n        Asset storage asset = assets[assetId];\r\n        bytes32 actualSHA256Hash = _getAssetActualSHA256Hash(assetId, false);\r\n        asset.hashValidated = assets[assetId].expectedSHA256Hash == actualSHA256Hash;\r\n        if(!asset.hashValidated) revert HashMismatch();\r\n        CatalogEntry storage catalogEntry = catalog[keccak256(abi.encodePacked(asset.expectedSHA256Hash, true))];\r\n        catalogEntry.assets.push(assetId);\r\n        emit AssetHashValidated(assetId, actualSHA256Hash);\r\n\r\n        return asset.hashValidated;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function validateActualAndExpectedHash(uint256 assetId) external view returns(bool hashesMatch) {\r\n        hashesMatch = assets[assetId].expectedSHA256Hash == _getAssetActualSHA256Hash(assetId, false);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function validateUnfinalizedActualAndExpectedHash(uint256 assetId) external view returns(bool hashesMatch) {\r\n        hashesMatch = assets[assetId].expectedSHA256Hash == _getAssetActualSHA256Hash(assetId, true);\r\n    }\r\n\r\n    /**\r\n     * Asset Retrieval\r\n     * Read as bytes, base64, string or hash\r\n     */\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function getAssetBytes(uint256 assetId) external view returns(bytes memory assetBytes) {\r\n        assetBytes = _getAssetBytes(assetId, false);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function getUnfinalizedAssetBytes(uint256 assetId) external view returns(bytes memory assetBytes) {\r\n        assetBytes = _getAssetBytes(assetId, true);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function getAssetBase64(uint256 assetId) external view returns(string memory assetBase64) {\r\n        assetBase64 = Base64.encode(_getAssetBytes(assetId, false));\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function getUnfinalizedAssetBase64(uint256 assetId) external view returns(string memory assetBase64) {\r\n        assetBase64 = Base64.encode(_getAssetBytes(assetId, true));\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function getAssetString(uint256 assetId) external view returns(string memory assetString) {\r\n        assetString = string(_getAssetBytes(assetId, false));\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function getUnfinalizedAssetString(uint256 assetId) external view returns(string memory assetString) {\r\n        assetString = string(_getAssetBytes(assetId, true));\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function getAssetActualSHA256Hash(uint256 assetId) external view returns(bytes32 assetHash) {\r\n        assetHash = _getAssetActualSHA256Hash(assetId, false);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IOnchainLibrary\r\n     */\r\n    function getUnfinalizedAssetActualSHA256Hash(uint256 assetId) external view returns(bytes32 assetHash) {\r\n        assetHash = _getAssetActualSHA256Hash(assetId, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Backwards compatible function for contracts using ScriptyBuilder\r\n     * @param data bytes array that will be converted to assetId\r\n     * @return script bytes array of the asset's stored data\r\n     */\r\n    function getScript(string calldata, bytes memory data) external view returns (bytes memory script) {\r\n        uint256 assetId;\r\n        for(uint256 dataIndex;dataIndex < data.length && dataIndex < 32;) {\r\n            assetId |= (uint256(uint8(data[dataIndex])) << (248 - 8 * dataIndex));\r\n\r\n            unchecked { ++dataIndex; }\r\n        }\r\n        script = _getAssetBytes(assetId, false);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the asset's stored data in bytes, reverts if asset is not finalized and allowUnfinalized is false\r\n     */\r\n    function _getAssetBytes(uint256 assetId, bool allowUnfinalized) internal view returns(bytes memory assetBytes) {\r\n        Asset storage asset = assets[assetId];\r\n\r\n        if(!allowUnfinalized && !asset.finalized) revert AssetNotFinalized();\r\n\r\n        address[] memory dataChunkAddresses = new address[](asset.dataChunkCount);\r\n\r\n        for(uint256 chunkIndex;chunkIndex < asset.dataChunkCount;) {\r\n            dataChunkAddresses[chunkIndex] = dataChunks[assetId][chunkIndex];\r\n\r\n            unchecked { ++chunkIndex; }\r\n        }\r\n\r\n        assetBytes = SSTORE2.readMultiple(dataChunkAddresses);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the SHA256 hash of the asset's stored data in bytes\r\n     *         Reverts if asset is not finalized and allowUnfinalized is false\r\n     */\r\n    function _getAssetActualSHA256Hash(uint256 assetId, bool allowUnfinalized) internal view returns(bytes32 assetHash) {\r\n        bytes memory assetBytes = _getAssetBytes(assetId, allowUnfinalized);\r\n        assetHash = sha256(assetBytes);\r\n    } \r\n\r\n    /**\r\n     * @notice Returns an array of Asset objects for a given array of assetIds\r\n     */\r\n    function _getAssetsById(uint256[] memory assetIds) internal view returns(Asset[] memory assetArr) {\r\n        assetArr = new Asset[](assetIds.length);\r\n\r\n        for(uint256 assetIndex = 0;assetIndex < assetIds.length;) {\r\n            assetArr[assetIndex] = assets[assetIds[assetIndex]];\r\n            unchecked { ++assetIndex; }\r\n        }\r\n    }\r\n}"
		},
		"contracts/interfaces/IOnchainLibrary.sol": {
			"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport {IContractScript} from \"./IContractScript.sol\";\r\n\r\n/**\r\n * @title OnchainLibrary\r\n * @author 0xth0mas (Layerr)\r\n * @notice OnchainLibrary is an open repository of assets that\r\n *         anyone may use and contribute to.\r\n */\r\ninterface IOnchainLibrary is IContractScript {\r\n\r\n    /// @dev asset metadata\r\n    struct Asset {\r\n        uint56 assetId;\r\n        address uploadedBy;\r\n        uint32 dataChunkCount;\r\n        bool finalized;\r\n        bool hashValidated;\r\n        bytes32 expectedSHA256Hash;\r\n        string name;\r\n    }\r\n\r\n    /// @dev array of assets matching a specific hash for searching\r\n    struct CatalogEntry {\r\n        uint256[] assets;\r\n    }\r\n\r\n    /// @dev Emitted when an asset is added to the library\r\n    event AssetAdded(uint256 indexed assetId, bytes32 indexed expectedSHA256Hash, uint32 dataChunkCount, string name);\r\n    /// @dev Emitted when the uploader updates the assets metadata\r\n    event AssetUpdated(uint256 indexed assetId, bytes32 indexed expectedSHA256Hash, uint32 dataChunkCount, string name);\r\n    /// @dev Emitted when the uploader finalizes an asset\r\n    event AssetFinalized(uint256 indexed assetId);\r\n    /// @dev Emitted when a data chunk is added to an asset\r\n    event DataChunkUploaded(uint256 indexed assetId, uint256 indexed chunkId, address indexed chunkDataPointer);\r\n    /// @dev Emitted when an asset's hash actual onchain hash is validated against its expected hash\r\n    event AssetHashValidated(uint256 indexed assetId, bytes32 indexed actualSHA256Hash);\r\n\r\n\r\n    /// @dev thrown when attempting to modify an asset that the sender did not initiate\r\n    error NotUploader();\r\n    /// @dev thrown when attempting to update a finalized asset\r\n    error AssetIsFinalized();\r\n    /// @dev thrown when attempting to use an asset that is not finalized\r\n    error AssetNotFinalized();\r\n    /// @dev thrown when attempting to upload a data chunk outside the specified range\r\n    error ExceedsChunkCount();\r\n    /// @dev thrown when attempting to store a data chunk larger than the max data chunk size\r\n    error ExceedsMaxChunkSize();\r\n    /// @dev thrown when expected hash does not match the actual asset hash\r\n    error HashMismatch();\r\n\r\n    /**\r\n     * @notice Begin the process of uploading an asset to the library.\r\n     * @param name Name of the asset\r\n     * @param expectedSHA256Hash Expected SHA256 hash when asset is finalized\r\n     * @param dataChunkCount Number of data chunks that will be uploaded\r\n     * @return newAssetId The ID of the asset that was created\r\n     */\r\n    function addAsset(string calldata name, bytes32 expectedSHA256Hash, uint32 dataChunkCount) external returns(uint256 newAssetId);\r\n\r\n    /**\r\n     * @notice Update asset information\r\n     * @dev This should be restricted to the uploader of the asset \r\n     *      and not allow updates after asset is marked finalized.\r\n     * @param assetId ID of the asset being updated\r\n     * @param name Name of the asset\r\n     * @param expectedSHA256Hash Expected SHA256 hash when asset is finalized\r\n     * @param dataChunkCount Number of data chunks that will be uploaded\r\n     */\r\n    function updateAsset(uint256 assetId, string calldata name, bytes32 expectedSHA256Hash, uint32 dataChunkCount) external;\r\n\r\n    /**\r\n     * @notice Finalize an asset to prevent future changes.\r\n     * @dev This should be restricted to the uploader of the asset.\r\n     * @param assetId ID of the asset being finalized\r\n     */\r\n    function finalizeAsset(uint256 assetId) external;\r\n\r\n    /**\r\n     * @notice Uploads a chunk of data to the asset at a specified index\r\n     * @param assetId ID of the asset\r\n     * @param chunkId Index position for the chunk of data within the asset\r\n     * @param chunkData Data to be stored for the asset at chunkId index\r\n     */\r\n    function uploadChunk(uint256 assetId, uint256 chunkId, bytes calldata chunkData) external;\r\n\r\n\r\n    /**\r\n     * @notice Uploads a chunk of data to the asset at a specified index\r\n     * @param assetId ID of the asset\r\n     * @param chunkId Index position for the chunk of data within the asset\r\n     * @param chunkDataPointer Address of the chunkData stored in SSTORE2 format\r\n     */\r\n    function addChunkByAddress(uint256 assetId, uint256 chunkId, address chunkDataPointer) external;\r\n\r\n    /**\r\n     * @notice Searches the catalog for all assets matching the expectedHash\r\n     * @param expectedHash The expected hash value to search for\r\n     * @return assetsFound All matches in the catalog for the expectedHash\r\n     */\r\n    function searchCatalogByExpectedHash(bytes32 expectedHash) external view returns(Asset[] memory assetsFound);\r\n\r\n    /**\r\n     * @notice Searches the catalog for all assets matching the validatedHash.\r\n     *         Validated hashes have been confirmed onchain by calculating the\r\n     *         hash of the asset's data and comparing to the expected hash for\r\n     *         the asset. Only finalized assets can have a validated hash.\r\n     * @param validatedHash The validated hash value to search for\r\n     * @return assetsFound All matches in the catalog for the validatedHash\r\n     */\r\n    function searchCatalogByValidatedHash(bytes32 validatedHash) external view returns(Asset[] memory);\r\n\r\n    /**\r\n     * @notice Searches the catalog for all assets matching the given name.\r\n     * @param name The asset name to search for\r\n     * @return assetsFound All matches in the catalog for the name\r\n     */\r\n    function searchCatalogByName(string calldata name) external view returns(Asset[] memory);\r\n\r\n    /**\r\n     * @notice Searches the catalog for all assets uploaded by an address.\r\n     * @param uploadedBy The uploader to search for\r\n     * @return assetsFound All matches in the catalog for the uploader\r\n     */\r\n    function searchCatalogByUploader(address uploadedBy) external view returns(Asset[] memory);\r\n\r\n    /**\r\n     * @notice Gets asset data for the given assetIds\r\n     * @param assetIds IDs of the assets to return data for\r\n     * @return assetArr the asset data for the given assetIds\r\n     */\r\n    function getAssetsById(uint256[] memory assetIds) external view returns(Asset[] memory assetArr);\r\n\r\n    /**\r\n     * @notice Returns the address that a data chunk will be stored at and if it already exists\r\n     * @dev Data chunks are stored using SSTORE2 with a CREATE2 address based on the init code to prevent\r\n     *      duplication of data.\r\n     * @param dataChunk data chunk that will be or is stored\r\n     * @return pointer storage address for the data chunk\r\n     * @return isUploaded flag if the data chunk is already uploaded\r\n     */\r\n    function getDataChunkAddress(bytes calldata dataChunk) external view returns(address pointer, bool isUploaded);\r\n\r\n    /**\r\n     * @notice Validates an asset's expected hash matches its actual hash\r\n     *         and store the result onchain.\r\n     * @param assetId ID of the asset being validated\r\n     * @return hashesMatch true if actual hash and expected hash are the same\r\n     */\r\n    function validateActualAndExpectedHashOnchain(uint256 assetId) external returns(bool hashesMatch);\r\n\r\n    /**\r\n     * @notice Checks an asset's expected hash compared to its actual hash.\r\n     *         Does not update onchain data. Only checks finalized assets.\r\n     * @param assetId ID of the asset being checked\r\n     * @return hashesMatch true if actual hash and expected hash are the same\r\n     */\r\n    function validateActualAndExpectedHash(uint256 assetId) external view returns(bool hashesMatch);\r\n\r\n    /**\r\n     * @notice Checks an asset's expected hash compared to its actual hash.\r\n     *         Does not update onchain data. Checks finalized and unfinalized assets.\r\n     * @param assetId ID of the asset being checked\r\n     * @return hashesMatch true if actual hash and expected hash are the same\r\n     */\r\n    function validateUnfinalizedActualAndExpectedHash(uint256 assetId) external view returns(bool hashesMatch);\r\n\r\n    /**\r\n     * @notice Reads the bytes data stored for the asset.\r\n     *         Only reads finalized assets.\r\n     * @param assetId ID of the asset\r\n     * @return assetBytes bytes data for the asset\r\n     */\r\n    function getAssetBytes(uint256 assetId) external view returns(bytes memory assetBytes);\r\n\r\n    /**\r\n     * @notice Reads the bytes data stored for the asset.\r\n     *         Reads finalized and unfinalized assets.\r\n     * @param assetId ID of the asset\r\n     * @return assetBytes bytes data for the asset\r\n     */\r\n    function getUnfinalizedAssetBytes(uint256 assetId) external view returns(bytes memory assetBytes);\r\n\r\n    /**\r\n     * @notice Reads the bytes data stored for the asset and converts to Base64.\r\n     *         Only reads finalized assets.\r\n     * @param assetId ID of the asset\r\n     * @return assetBase64 base64 data for the asset\r\n     */\r\n    function getAssetBase64(uint256 assetId) external view returns(string memory assetBase64);\r\n\r\n    /**\r\n     * @notice Reads the bytes data stored for the asset and converts to Base64.\r\n     *         Reads finalized and unfinalized assets.\r\n     * @param assetId ID of the asset\r\n     * @return assetBase64 base64 data for the asset\r\n     */\r\n    function getUnfinalizedAssetBase64(uint256 assetId) external view returns(string memory assetBase64);\r\n\r\n    /**\r\n     * @notice Reads the bytes data stored for the asset and converts to a string.\r\n     *         Only reads finalized assets.\r\n     * @param assetId ID of the asset\r\n     * @return assetString string data for the asset\r\n     */\r\n    function getAssetString(uint256 assetId) external view returns(string memory assetString);\r\n\r\n    /**\r\n     * @notice Reads the bytes data stored for the asset and converts to a string.\r\n     *         Reads finalized and unfinalized assets.\r\n     * @param assetId ID of the asset\r\n     * @return assetString string data for the asset\r\n     */\r\n    function getUnfinalizedAssetString(uint256 assetId) external view returns(string memory assetString);\r\n\r\n    /**\r\n     * @notice Reads the bytes data stored for the asset and calculates the SHA256 hash.\r\n     *         Only reads finalized assets.\r\n     * @param assetId ID of the asset\r\n     * @return assetHash hash of the asset data\r\n     */\r\n    function getAssetActualSHA256Hash(uint256 assetId) external view returns(bytes32 assetHash);\r\n\r\n    /**\r\n     * @notice Reads the bytes data stored for the asset and calculates the SHA256 hash.\r\n     *         Reads finalized and unfinalized assets.\r\n     * @param assetId ID of the asset\r\n     * @return assetHash hash of the asset data\r\n     */\r\n    function getUnfinalizedAssetActualSHA256Hash(uint256 assetId) external view returns(bytes32 assetHash);\r\n}"
		},
		"contracts/interfaces/IContractScript.sol": {
			"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\n///////////////////////////////////////////////////////////\r\n// ░██████╗░█████╗░██████╗░██╗██████╗░████████╗██╗░░░██╗ //\r\n// ██╔════╝██╔══██╗██╔══██╗██║██╔══██╗╚══██╔══╝╚██╗░██╔╝ //\r\n// ╚█████╗░██║░░╚═╝██████╔╝██║██████╔╝░░░██║░░░░╚████╔╝░ //\r\n// ░╚═══██╗██║░░██╗██╔══██╗██║██╔═══╝░░░░██║░░░░░╚██╔╝░░ //\r\n// ██████╔╝╚█████╔╝██║░░██║██║██║░░░░░░░░██║░░░░░░██║░░░ //\r\n// ╚═════╝░░╚════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░░░░╚═╝░░░░░░╚═╝░░░ //\r\n///////////////////////////////////////////////////////////\r\n\r\ninterface IContractScript {\r\n    // =============================================================\r\n    //                            GETTERS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @notice Get the full script\r\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\r\n     * @param data - Arbitrary data to be passed to storage\r\n     * @return script - Full script from merged chunks\r\n     */\r\n    function getScript(string calldata name, bytes memory data)\r\n        external\r\n        view\r\n        returns (bytes memory script);\r\n}"
		},
		"contracts/lib/solady/utils/Base64.sol": {
			"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Library to encode strings in Base64.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\r\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\r\nlibrary Base64 {\r\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\r\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\r\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\r\n    /// @param noPadding Whether to strip away the padding.\r\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let dataLength := mload(data)\r\n\r\n            if dataLength {\r\n                // Multiply by 4/3 rounded up.\r\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\r\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\r\n\r\n                // Set `result` to point to the start of the free memory.\r\n                result := mload(0x40)\r\n\r\n                // Store the table into the scratch space.\r\n                // Offsetted by -1 byte so that the `mload` will load the character.\r\n                // We will rewrite the free memory pointer at `0x40` later with\r\n                // the allocated size.\r\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\r\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\r\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\r\n\r\n                // Skip the first slot, which stores the length.\r\n                let ptr := add(result, 0x20)\r\n                let end := add(ptr, encodedLength)\r\n\r\n                // Run over the input, 3 bytes at a time.\r\n                for {} 1 {} {\r\n                    data := add(data, 3) // Advance 3 bytes.\r\n                    let input := mload(data)\r\n\r\n                    // Write 4 bytes. Optimized for fewer stack operations.\r\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\r\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\r\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\r\n                    mstore8(3, mload(and(input, 0x3F)))\r\n                    mstore(ptr, mload(0x00))\r\n\r\n                    ptr := add(ptr, 4) // Advance 4 bytes.\r\n                    if iszero(lt(ptr, end)) { break }\r\n                }\r\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\r\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\r\n                let o := div(2, mod(dataLength, 3))\r\n                // Offset `ptr` and pad with '='. We can simply write over the end.\r\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\r\n                // Set `o` to zero if there is padding.\r\n                o := mul(iszero(iszero(noPadding)), o)\r\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\r\n                mstore(result, sub(encodedLength, o)) // Store the length.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\r\n    /// Equivalent to `encode(data, false, false)`.\r\n    function encode(bytes memory data) internal pure returns (string memory result) {\r\n        result = encode(data, false, false);\r\n    }\r\n\r\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\r\n    /// Equivalent to `encode(data, fileSafe, false)`.\r\n    function encode(bytes memory data, bool fileSafe)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        result = encode(data, fileSafe, false);\r\n    }\r\n\r\n    /// @dev Decodes base64 encoded `data`.\r\n    ///\r\n    /// Supports:\r\n    /// - RFC 4648 (both standard and file-safe mode).\r\n    /// - RFC 3501 (63: ',').\r\n    ///\r\n    /// Does not support:\r\n    /// - Line breaks.\r\n    ///\r\n    /// Note: For performance reasons,\r\n    /// this function will NOT revert on invalid `data` inputs.\r\n    /// Outputs for invalid inputs will simply be undefined behaviour.\r\n    /// It is the user's responsibility to ensure that the `data`\r\n    /// is a valid base64 encoded string.\r\n    function decode(string memory data) internal pure returns (bytes memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let dataLength := mload(data)\r\n\r\n            if dataLength {\r\n                let decodedLength := mul(shr(2, dataLength), 3)\r\n\r\n                for {} 1 {} {\r\n                    // If padded.\r\n                    if iszero(and(dataLength, 3)) {\r\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\r\n                        // forgefmt: disable-next-item\r\n                        decodedLength := sub(\r\n                            decodedLength,\r\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\r\n                        )\r\n                        break\r\n                    }\r\n                    // If non-padded.\r\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\r\n                    break\r\n                }\r\n                result := mload(0x40)\r\n\r\n                // Write the length of the bytes.\r\n                mstore(result, decodedLength)\r\n\r\n                // Skip the first slot, which stores the length.\r\n                let ptr := add(result, 0x20)\r\n                let end := add(ptr, decodedLength)\r\n\r\n                // Load the table into the scratch space.\r\n                // Constants are optimized for smaller bytecode with zero gas overhead.\r\n                // `m` also doubles as the mask of the upper 6 bits.\r\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\r\n                mstore(0x5b, m)\r\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\r\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\r\n\r\n                for {} 1 {} {\r\n                    // Read 4 bytes.\r\n                    data := add(data, 4)\r\n                    let input := mload(data)\r\n\r\n                    // Write 3 bytes.\r\n                    // forgefmt: disable-next-item\r\n                    mstore(ptr, or(\r\n                        and(m, mload(byte(28, input))),\r\n                        shr(6, or(\r\n                            and(m, mload(byte(29, input))),\r\n                            shr(6, or(\r\n                                and(m, mload(byte(30, input))),\r\n                                shr(6, mload(byte(31, input)))\r\n                            ))\r\n                        ))\r\n                    ))\r\n                    ptr := add(ptr, 3)\r\n                    if iszero(lt(ptr, end)) { break }\r\n                }\r\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\r\n                mstore(end, 0) // Zeroize the slot after the bytes.\r\n                mstore(0x60, 0) // Restore the zero slot.\r\n            }\r\n        }\r\n    }\r\n}"
		},
		"contracts/lib/SSTORE2/SSTORE2.sol": {
			"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./utils/Bytecode.sol\";\r\n\r\n/**\r\n  @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.\r\n  @author Agustin Aguilar <aa@horizon.io>\r\n\r\n  Readme: https://github.com/0xsequence/sstore2#readme\r\n*/\r\nlibrary SSTORE2 {\r\n  error WriteError();\r\n  error DataAlreadyExists(address pointer);\r\n\r\n  /**\r\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\r\n    @dev The pointer is a contract address with `_data` as code\r\n    @param _data to be written\r\n    @return pointer Pointer to the written `_data`\r\n  */\r\n  function write(bytes memory _data) internal returns (address pointer) {\r\n    // Append 00 to _data so contract can't be called\r\n    // Build init code\r\n    bytes memory initCode = Bytecode.creationCodeFor(\r\n      abi.encodePacked(\r\n        hex'00',\r\n        _data\r\n      )\r\n    );\r\n\r\n    pointer = findCreate2Address(initCode);\r\n    if(Bytecode.codeSize(pointer) > 0) revert DataAlreadyExists(pointer);\r\n\r\n    // Deploy contract using create\r\n    assembly { pointer := create2(0, add(initCode, 0x20), mload(initCode), 0) }\r\n\r\n    // Address MUST be non-zero\r\n    if (pointer == address(0)) revert WriteError();\r\n  }\r\n\r\n  /**\r\n    @notice Looks up the create2 address for `_data`\r\n    @param _data to look up\r\n    @return pointer Pointer to where `_data` is or will be stored\r\n  */\r\n  function search(bytes memory _data) internal view returns (address pointer, bool isUploaded) {\r\n    // Append 00 to _data so contract can't be called\r\n    // Build init code\r\n    bytes memory initCode = Bytecode.creationCodeFor(\r\n      abi.encodePacked(\r\n        hex'00',\r\n        _data\r\n      )\r\n    );\r\n\r\n    pointer = findCreate2Address(initCode);\r\n    isUploaded = Bytecode.codeSize(pointer) > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Compute the address of the contract that will be created when\r\n   * submitting a given salt or nonce to the contract along with the contract's\r\n   * initialization code. The CREATE2 address is computed in accordance with\r\n   * EIP-1014, and adheres to the formula therein of\r\n   * `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]` when\r\n   * performing the computation. The computed address is then checked for any\r\n   * existing contract code - if so, the null address will be returned instead.\r\n   * From 0age's Keyless CREATE2 factory\r\n   * @param initCode bytes The contract initialization code to be used.\r\n   * that will be passed into the CREATE2 address calculation.\r\n   * @return deploymentAddress Address of the contract that will be created, or the null address\r\n   * if a contract has already been deployed to that address.\r\n   */\r\n  function findCreate2Address(\r\n    bytes memory initCode\r\n  ) internal view returns (address deploymentAddress) {\r\n    // determine the address where the contract will be deployed.\r\n    deploymentAddress = address(\r\n      uint160(                      // downcast to match the address type.\r\n        uint256(                    // convert to uint to truncate upper digits.\r\n          keccak256(                // compute the CREATE2 hash using 4 inputs.\r\n            abi.encodePacked(       // pack all inputs to the hash together.\r\n              hex\"ff\",              // start with 0xff to distinguish from RLP.\r\n              address(this),        // this contract will be the caller.\r\n              uint256(0),           // pass in the supplied salt value.\r\n              keccak256(            // pass in the hash of initialization code.\r\n                abi.encodePacked(\r\n                  initCode\r\n                )\r\n              )\r\n            )\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \r\n    @dev The function is intended for reading pointers generated by `write`\r\n    @param _pointer to be read\r\n    @return data read from `_pointer` contract\r\n  */\r\n  function read(address _pointer) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(_pointer, 1, type(uint256).max);\r\n  }\r\n\r\n\r\n  /**\r\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \r\n    @dev The function is intended for reading pointers generated by `write`\r\n  */\r\n  function readMultiple(address[] memory _pointers) internal view returns (bytes memory) {\r\n    return Bytecode.codeAtMultiple(_pointers);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \r\n    @dev The function is intended for reading pointers generated by `write`\r\n    @param _pointer to be read\r\n    @param _start number of bytes to skip\r\n    @return data read from `_pointer` contract\r\n  */\r\n  function read(address _pointer, uint256 _start) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \r\n    @dev The function is intended for reading pointers generated by `write`\r\n    @param _pointer to be read\r\n    @param _start number of bytes to skip\r\n    @param _end index before which to end extraction\r\n    @return data read from `_pointer` contract\r\n  */\r\n  function read(address _pointer, uint256 _start, uint256 _end) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\r\n  }\r\n}"
		},
		"contracts/lib/SSTORE2/utils/Bytecode.sol": {
			"content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\nlibrary Bytecode {\r\n  error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\r\n\r\n  /**\r\n    @notice Generate a creation code that results on a contract with `_code` as bytecode\r\n    @param _code The returning value of the resulting `creationCode`\r\n    @return creationCode (constructor) for new contract\r\n  */\r\n  function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {\r\n    /*\r\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\r\n      0x01    0x80         0x80        DUP1                size size\r\n      0x02    0x60         0x600e      PUSH1 14            14 size size\r\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\r\n      0x04    0x39         0x39        CODECOPY            size\r\n      0x05    0x60         0x6000      PUSH1 00            0 size\r\n      0x06    0xf3         0xf3        RETURN\r\n      <CODE>\r\n    */\r\n\r\n    return abi.encodePacked(\r\n      hex\"63\",\r\n      uint32(_code.length),\r\n      hex\"80_60_0E_60_00_39_60_00_F3\",\r\n      _code\r\n    );\r\n  }\r\n\r\n  /**\r\n    @notice Returns the size of the code on a given address\r\n    @param _addr Address that may or may not contain code\r\n    @return size of the code on the given `_addr`\r\n  */\r\n  function codeSize(address _addr) internal view returns (uint256 size) {\r\n    assembly { size := extcodesize(_addr) }\r\n  }\r\n\r\n  /**\r\n    @notice Returns the code of a given address\r\n    @dev It will fail if `_end < _start`\r\n    @param _addr Address that may or may not contain code\r\n    @param _start number of bytes of code to skip on read\r\n    @param _end index before which to end extraction\r\n    @return oCode read from `_addr` deployed bytecode\r\n\r\n    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\r\n  */\r\n  function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {\r\n    uint256 csize = codeSize(_addr);\r\n    if (csize == 0) return bytes(\"\");\r\n\r\n    if (_start > csize) return bytes(\"\");\r\n    if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); \r\n\r\n    unchecked {\r\n      uint256 reqSize = _end - _start;\r\n      uint256 maxSize = csize - _start;\r\n\r\n      uint256 size = maxSize < reqSize ? maxSize : reqSize;\r\n\r\n      assembly {\r\n        // allocate output byte array - this could also be done without assembly\r\n        // by using o_code = new bytes(size)\r\n        oCode := mload(0x40)\r\n        // new \"memory end\" including padding\r\n        mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n        // store length in memory\r\n        mstore(oCode, size)\r\n        // actually retrieve the code, this needs assembly\r\n        extcodecopy(_addr, add(oCode, 0x20), _start, size)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n    @notice Returns the code of the given addresses\r\n\r\n    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\r\n  */\r\n  function codeAtMultiple(address[] memory _addrs) internal view returns (bytes memory oCode) {\r\n    uint256 totalSize;\r\n    for(uint256 addrIndex;addrIndex < _addrs.length;) {\r\n        uint256 csize = codeSize(_addrs[addrIndex]);\r\n        unchecked {\r\n            if(csize > 0) --csize;\r\n            totalSize += csize;\r\n            ++addrIndex;\r\n        }\r\n    }\r\n    if (totalSize == 0) return bytes(\"\");\r\n    oCode = new bytes(totalSize);\r\n\r\n    unchecked {\r\n      assembly {\r\n        let currentPosition := add(oCode, 0x20)\r\n        let addressEnd := add(0x20, add(_addrs, shl(5, mload(_addrs))))\r\n        for { let addressOffset := add(_addrs, 0x20) } 1 {} {\r\n            mstore(0x00, mload(addressOffset))\r\n            addressOffset := add(addressOffset, 0x20)\r\n            mstore(0x20, extcodesize(mload(0x00)))\r\n            if not(iszero(mload(0x20))) {\r\n                extcodecopy(mload(0x00), currentPosition, 0x01, sub(mload(0x20), 0x01))\r\n                currentPosition := add(currentPosition, sub(mload(0x20), 0x01))\r\n                if iszero(lt(addressOffset, addressEnd)) { break }\r\n            }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}"
		}
	},
	"settings": {
		"optimizer": {
			"enabled": true,
			"runs": 33333
		},
		"evmVersion": "paris",
		"viaIR": true,
		"outputSelection": {
			"*": {
				"*": [
					"abi",
					"evm.bytecode",
					"evm.deployedBytecode",
					"evm.methodIdentifiers",
					"metadata"
				],
				"": [
					"ast"
				]
			}
		}
	}
}